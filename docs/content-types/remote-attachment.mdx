---
sidebar_label: Remote Attachments
sidebar_position: 20
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Remote Attachment Content Type

Remote attachments of any size can be sent using the `RemoteAttachmentCodec` and a storage provider.

### Install the package

```bash
npm i --save @xmtp/content-type-remote-attachment
```

### Import and register codecs

```tsx
// Import the codecs we're going to use
import {
  AttachmentCodec,
  RemoteAttachmentCodec,
} from "@xmtp/content-type-remote-attachment";
```

```tsx
// Create the XMTP client
const xmtp = await Client.create(signer, { env: "dev" });
// Register the codecs. AttachmentCodec is for local attachments (<1MB)
xmtp.registerCodec(new AttachmentCodec());
//RemoteAttachmentCodec is for remote attachments (>1MB) using thirdweb storage
xmtp.registerCodec(new RemoteAttachmentCodec());
```

### Create an attachment object

<Tabs>
<TabItem value="backend" label="Backend">

```tsx
// Local file details
const fs = require("fs");
const path = require("path");

const filePath = "xmtp.png";
const data = fs.readFileSync(filePath);
const filename = path.basename(filePath);
const extname = path.extname(filePath);
console.log(`Filename: ${filename}`);
console.log(`Type: ${extname}`);
```

</TabItem>
<TabItem value="frontend" label="Frontend">

```tsx
// Local file details
const readAsArrayBuffer = (file) =>
  new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () =>
      reader.result instanceof ArrayBuffer
        ? resolve(reader.result)
        : reject(new Error("Not an ArrayBuffer"));
    reader.readAsArrayBuffer(file);
  });
const data = await readAsArrayBuffer(file);
```

</TabItem>
</Tabs>

```tsx
// Local file details
const attachment = {
  filename: filename,
  mimeType: extname,
  data: new Uint8Array(data),
};
```

### Encrypt the attachment

Use the `RemoteAttachmentCodec.encodeEncrypted` to encrypt the attachment:

```tsx
const encryptedEncoded = await RemoteAttachmentCodec.encodeEncrypted(
  attachment,
  new AttachmentCodec(),
);
```

### Upload the encrypted attachment

Upload the encrypted attachment anywhere where it will be accessible via an HTTPS GET request. For example, you can use web3.storage:

<Tabs>
<TabItem value="web3storage" label="web3storage">

```tsx
const { Web3Storage } = require("web3.storage");

class Upload {
  constructor(name, data) {
    this.name = name;
    this.data = data;
  }

  stream() {
    const self = this;
    return new ReadableStream({
      start(controller) {
        controller.enqueue(Buffer.from(self.data));
        controller.close();
      },
    });
  }
}

const upload = new Upload("uploadIdOfYourChoice", encryptedEncoded.payload);

const web3Storage = new Web3Storage({
  token: "YOURTOKENHERE",
});

const cid = await web3Storage.put([upload]);
const url = `https://${cid}.ipfs.w3s.link/uploadIdOfYourChoice`;
```

</TabItem>
<TabItem value="thirdweb" label="Thridweb">

```tsx
import { useStorageUpload } from "@thirdweb-dev/react";
const { mutateAsync: upload } = useStorageUpload();
const uploadUrl = await upload({
  //encryptedEncoded.payload.buffer is a Uint8Array
  //We need to convert it to a File to upload it to the IPFS network
  data: [new File([encryptedEncoded.payload.buffer], file.name)], // Convert Uint8Array back to File
  options: { uploadWithGatewayUrl: true, uploadWithoutDirectory: true },
});
const url = uploadUrl[0];
```

</TabItem>
</Tabs>

### Create a remote attachment

Now that you have a `url`, you can create a `RemoteAttachment`.

```tsx
const remoteAttachment = {
  url: url,
  contentDigest: encryptedEncoded.digest,
  salt: encryptedEncoded.salt,
  nonce: encryptedEncoded.nonce,
  secret: encryptedEncoded.secret,
  scheme: "https://",
  filename: attachment.filename,
  contentLength: attachment.data.byteLength,
};
```

### Send a remote attachment

Now that you have a remote attachment, you can send it:

```tsx
await conversation.send(remoteAttachment, {
  contentFallback:
    "[Attachment] Cannot display ${remoteAttachment.filename}. This app does not support attachments yet.",
  contentType: ContentTypeRemoteAttachment,
});
```

As shown in the example above, you **must** provide a `contentFallback` value. Use it to provide an alt text-like description of the original content. Providing a `contentFallback` value enables clients that don't support the content type to still display something meaningful.

:::caution

If you don't provide a `contentFallback` value, clients that don't support the content type will display an empty message. This results in a poor user experience and breaks interoperability.

:::

## Download, decrypt, and decode the attachment

Now that you can receive a remote attachment, you need a way to receive a remote attachment. For example:

```tsx
const encryptedEncoded = await RemoteAttachmentCodec.encodeEncrypted(
  attachment,
  new AttachmentCodec(),
);
```

You now have the original attachment:

```
attachment.filename // => "screenshot.png"
attachment.mimeType // => "image/png",
attachment.data // => [the PNG data]
```

## Create a preview attachment object

Once you have the attachment object created, you can also create a preview for what to show in a message input before sending:

```tsx
URL.createObjectURL(
    new Blob([Buffer.from(somePNGData)], {
    type: attachment.mimeType,
  }),
),
```
